<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>rt</title>


</head>
<iframe name="myiframe" id="myrame" src="https://product.360che.com/s26/6512_64_Article.html" frameborder="0" align="left" width="100%" height="900px" scrolling="no"></iframe>
<body>


    <script type="text/javascript">
        var start_time = (new Date()).getTime();
        var a = setInterval(function(){
if(document.readyState=="complete"){aa();}
},1)
function aa(){
end_time = (new Date()).getTime();
alert(end_time - start_time);

    var t = performance.timing;

    var times = {};

    start = t.fetchStart,
    dnsTime = 0,
    tcpTime = 0,
    firstPaintTime = 0,
    domRenderTime = 0,
    loadTime = 0;

dnsTime = t.domainLookupEnd - t.domainLookupStart;
tcpTime = t.connectEnd - t.connectStart;
firstPaintTime = t.responseStart - start;
domRenderTime = t.domContentLoadedEventEnd - start;
loadTime = t.loadEventEnd - start;

console.log('开始时间:', start ,'\nDNS解析时间:', dnsTime , '\nTCP建立时间:', tcpTime, '\n首屏时间:', firstPaintTime,
 '\ndom渲染完成时间:', domRenderTime, '\n页面onload时间:', loadTime);
    console.log('解析dom树耗时:',window.performance.timing.domComplete - window.performance.timing.domInteractive)
    console.log('request请求耗时:',window.performance.timing.responseEnd - window.performance.timing.responseStart)
    console.log('白屏时间:',window.performance.timing.domLoading - window.performance.timing.fetchStart)
    console.log('domready时间:',window.performance.timing.domContentLoadedEventEnd - window.performance.timing.fetchStart)
    console.log('onload时间:',window.performance.timing.loadEventEnd - window.performance.timing.fetchStart)
    console.log("----------------------")


    //【重要】页面加载完成的时间
    //【原因】这几乎代表了用户等待页面可用的时间
    times.loadPage = t.loadEventEnd - t.navigationStart;

    //【重要】解析 DOM 树结构的时间
    //【原因】反省下你的 DOM 树嵌套是不是太多了！
    times.domReady = t.domComplete - t.responseEnd;

    //【重要】重定向的时间
    //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com
    times.redirect = t.redirectEnd - t.redirectStart;

    //【重要】DNS 查询时间
    //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？
    // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)
    times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

    //【重要】读取页面第一个字节的时间
    //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？
    // TTFB 即 Time To First Byte 的意思
    // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte
    times.ttfb = t.responseStart - t.navigationStart;

    //【重要】内容加载完成的时间
    //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？
    times.request = t.responseEnd - t.requestStart;

    //【重要】执行 onload 回调函数的时间
    //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？
    times.loadEvent = t.loadEventEnd - t.loadEventStart;

    // DNS 缓存时间
    times.appcache = t.domainLookupStart - t.fetchStart;

    // 卸载页面的时间
    times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;

    // TCP 建立连接完成握手的时间
    times.connect = t.connectEnd - t.connectStart;
    console.log(times)
    clearInterval(a);
}

</script>
</body>
</html>